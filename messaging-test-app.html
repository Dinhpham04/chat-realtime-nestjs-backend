<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üí¨ Chat & File Messaging Test App</title>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: #333;
        }

        .app-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            display: grid;
            grid-template-columns: 280px 320px 1fr;
            gap: 20px;
            height: 100vh;
        }

        .sidebar {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            overflow-y: auto;
        }

        .conversations-sidebar {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .conversations-header {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px 20px;
            text-align: center;
            font-weight: bold;
        }

        .conversations-search {
            padding: 15px;
            border-bottom: 1px solid #e1e8ed;
        }

        .search-input {
            width: 100%;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-radius: 20px;
            font-size: 13px;
            outline: none;
        }

        .search-input:focus {
            border-color: #667eea;
        }

        .conversations-list {
            flex: 1;
            overflow-y: auto;
        }

        .conversation-item {
            display: flex;
            align-items: center;
            padding: 12px 15px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
            transition: background-color 0.2s ease;
            position: relative;
        }

        .conversation-item:hover {
            background-color: #f8f9fa;
        }

        .conversation-item.active {
            background-color: #e3f2fd;
            border-right: 3px solid #667eea;
        }

        .conversation-avatar {
            position: relative;
            margin-right: 12px;
            flex-shrink: 0;
        }

        .avatar {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 16px;
        }

        .avatar img {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            object-fit: cover;
        }

        .online-indicator {
            position: absolute;
            bottom: 2px;
            right: 2px;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #2ed573;
            border: 2px solid white;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .online-indicator.online {
            opacity: 1;
        }

        .conversation-content {
            flex: 1;
            min-width: 0;
        }

        .conversation-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .conversation-name {
            font-weight: 600;
            font-size: 14px;
            color: #333;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .conversation-time {
            font-size: 11px;
            color: #666;
            flex-shrink: 0;
        }

        .last-message {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .last-message-content {
            font-size: 12px;
            color: #666;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }

        .last-message-content .sender {
            font-weight: 500;
            color: #555;
        }

        .conversation-badges {
            display: flex;
            align-items: center;
            gap: 5px;
            flex-shrink: 0;
            margin-left: 5px;
        }

        .unread-count {
            background: #ff4757;
            color: white;
            border-radius: 10px;
            font-size: 10px;
            font-weight: bold;
            padding: 2px 6px;
            min-width: 16px;
            text-align: center;
        }

        .read-status {
            font-size: 10px;
            color: #4facfe;
        }

        .read-status.unread {
            color: #ccc;
        }

        .new-conversation-btn {
            position: sticky;
            bottom: 15px;
            left: 15px;
            right: 15px;
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            border: none;
            padding: 12px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
            transition: transform 0.2s ease;
            margin: 15px;
        }

        .new-conversation-btn:hover {
            transform: translateY(-2px);
        }

        .main-chat {
            display: flex;
            flex-direction: column;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(31, 38, 135, 0.37);
            overflow: hidden;
        }

        .chat-header {
            background: linear-gradient(90deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .connection-status {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4757;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #2ed573;
        }

        @keyframes pulse {
            0% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.1);
                opacity: 0.7;
            }

            100% {
                transform: scale(1);
                opacity: 1;
            }
        }

        .messages-container {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 15px;
            max-width: 70%;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .message.sent {
            margin-left: auto;
        }

        .message.received {
            margin-right: auto;
        }

        .message-bubble {
            padding: 12px 16px;
            border-radius: 18px;
            word-wrap: break-word;
            position: relative;
        }

        .message.sent .message-bubble {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .message.received .message-bubble {
            background: white;
            border: 1px solid #e1e8ed;
            color: #333;
        }

        .message-info {
            font-size: 11px;
            opacity: 0.7;
            margin-top: 5px;
        }

        .file-attachment {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 10px;
            margin-top: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .message.received .file-attachment {
            background: #f1f3f4;
            border: 1px solid #e1e8ed;
        }

        .file-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 16px;
            margin-right: 10px;
        }

        .file-details {
            display: flex;
            align-items: center;
        }

        .file-info {
            flex: 1;
        }

        .file-name {
            font-weight: bold;
            font-size: 13px;
        }

        .file-size {
            font-size: 11px;
            opacity: 0.8;
        }

        .download-btn {
            background: #4facfe;
            color: white;
            border: none;
            padding: 6px 12px;
            border-radius: 15px;
            cursor: pointer;
            font-size: 11px;
            text-decoration: none;
            display: inline-block;
            transition: background 0.3s ease;
        }

        .download-btn:hover {
            background: #2980b9;
        }

        .message-input-area {
            background: white;
            padding: 20px;
            border-top: 1px solid #e1e8ed;
        }

        .input-container {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }

        .message-input {
            flex: 1;
            border: 2px solid #e1e8ed;
            border-radius: 25px;
            padding: 12px 20px;
            font-size: 14px;
            resize: none;
            max-height: 100px;
            min-height: 44px;
        }

        .message-input:focus {
            outline: none;
            border-color: #4facfe;
        }

        .input-actions {
            display: flex;
            gap: 8px;
        }

        .action-btn {
            width: 44px;
            height: 44px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            transition: all 0.3s ease;
        }

        .file-btn {
            background: #ff6b6b;
            color: white;
        }

        .send-btn {
            background: #4facfe;
            color: white;
        }

        .action-btn:hover {
            transform: scale(1.1);
        }

        .action-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }

        .section {
            margin-bottom: 20px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        .section h3 {
            margin-bottom: 10px;
            color: #333;
            font-size: 16px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            font-size: 12px;
            color: #666;
        }

        .form-control {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 12px;
        }

        .btn {
            background: #4facfe;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.3s ease;
            width: 100%;
            margin-bottom: 8px;
        }

        .btn:hover {
            background: #3498db;
        }

        .btn-success {
            background: #2ed573;
        }

        .btn-warning {
            background: #ffa502;
        }

        .btn-danger {
            background: #ff4757;
        }

        .btn-success:hover {
            background: #27ae60;
        }

        .btn-warning:hover {
            background: #e67e22;
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .file-upload-area {
            border: 2px dashed #ddd;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .file-upload-area.dragover {
            border-color: #4facfe;
            background: rgba(79, 172, 254, 0.1);
        }

        .upload-result {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-size: 11px;
            max-height: 200px;
            overflow-y: auto;
        }

        .upload-result.success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
        }

        .upload-result.error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
        }

        .debug-log {
            background: #2c3e50;
            color: #ecf0f1;
            border-radius: 8px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            max-height: 150px;
            overflow-y: auto;
        }

        .typing-indicator {
            display: none;
            padding: 10px 20px;
            font-style: italic;
            color: #666;
            font-size: 12px;
        }

        .typing-dots {
            display: inline-block;
            animation: typing 1.4s infinite;
        }

        @keyframes typing {

            0%,
            60%,
            100% {
                opacity: 0;
            }

            30% {
                opacity: 1;
            }
        }

        .file-preview {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
        }

        .file-preview-item {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 8px;
            font-size: 11px;
            max-width: 150px;
        }

        .batch-files {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 10px;
            margin-top: 8px;
        }

        .batch-file-item {
            display: flex;
            align-items: center;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .batch-file-item:last-child {
            border-bottom: none;
        }

        @media (max-width: 768px) {
            .app-container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                height: 100vh;
            }

            .sidebar {
                max-height: 200px;
                overflow-y: auto;
            }

            .conversations-sidebar {
                display: none;
            }
        }
    </style>
</head>

<body>
    <div class="app-container">
        <!-- Sidebar Controls -->
        <div class="sidebar">
            <!-- Connection Section -->
            <div class="section">
                <h3><i class="fas fa-wifi"></i> K·∫øt n·ªëi</h3>
                <div class="connection-status">
                    <div class="status-dot" id="statusDot"></div>
                    <span id="connectionText">Disconnected</span>
                </div>
                <div class="form-group">
                    <label>Access Token</label>
                    <textarea class="form-control" id="accessToken" placeholder="Nh·∫≠p JWT access token..." rows="3"
                        style="font-family: monospace; font-size: 10px;"></textarea>
                </div>
                <div class="form-group">
                    <label>Device ID</label>
                    <input type="text" class="form-control" id="deviceId" placeholder="test_device_web_123">
                </div>
                <div class="form-group">
                    <label>User Info</label>
                    <div id="userInfo"
                        style="font-size: 11px; color: #666; background: #f8f9fa; padding: 8px; border-radius: 5px; min-height: 30px;">
                        Ch∆∞a k·∫øt n·ªëi
                    </div>
                </div>
                <button type="button" class="btn" onclick="connect()">
                    <i class="fas fa-plug"></i> K·∫øt n·ªëi
                </button>
                <button type="button" class="btn btn-danger" onclick="disconnect()">
                    <i class="fas fa-unplug"></i> Ng·∫Øt k·∫øt n·ªëi
                </button>
                <button type="button" class="btn btn-warning" onclick="clearToken()">
                    <i class="fas fa-eraser"></i> X√≥a Token
                </button>
            </div>

            <!-- Conversation Settings -->
            <div class="section">
                <h3><i class="fas fa-comments"></i> Cu·ªôc tr√≤ chuy·ªán</h3>
                <div class="form-group">
                    <label>ID Cu·ªôc tr√≤ chuy·ªán</label>
                    <input type="text" class="form-control" id="conversationId" value="test_conv_123">
                </div>
                <div class="form-group">
                    <label>Lo·∫°i tin nh·∫Øn</label>
                    <select class="form-control" id="messageType">
                        <option value="text">üìù VƒÉn b·∫£n</option>
                        <option value="image">üñºÔ∏è H√¨nh ·∫£nh</option>
                        <option value="audio">üéµ √Çm thanh</option>
                        <option value="video">üé• Video</option>
                        <option value="document">üìÑ T√†i li·ªáu</option>
                        <option value="file">üìé T·ªáp</option>
                    </select>
                </div>
            </div>

            <!-- File Upload Section -->
            <div class="section">
                <h3><i class="fas fa-cloud-upload-alt"></i> T·∫£i t·ªáp l√™n</h3>
                <div class="file-upload-area" id="fileUploadArea">
                    <i class="fas fa-cloud-upload-alt" style="font-size: 24px; color: #ccc; margin-bottom: 10px;"></i>
                    <p style="margin: 0; font-size: 12px; color: #666;">
                        K√©o th·∫£ t·ªáp v√†o ƒë√¢y ho·∫∑c nh·∫•p ƒë·ªÉ ch·ªçn
                    </p>
                    <input type="file" id="fileInput" accept="*/*" multiple style="display: none;">
                </div>
                <div class="file-preview" id="filePreview"></div>
                <button type="button" class="btn" onclick="uploadFiles(event)">
                    <i class="fas fa-upload"></i> T·∫£i l√™n Server
                </button>
                <div class="upload-result" id="uploadResult"></div>
            </div>

            <!-- Quick Actions -->
            <div class="section">
                <h3><i class="fas fa-bolt"></i> Thao t√°c nhanh</h3>
                <button type="button" class="btn btn-success" onclick="sendQuickMessage()">
                    <i class="fas fa-paper-plane"></i> G·ª≠i tin nhanh
                </button>
                <button type="button" class="btn btn-warning" onclick="shareFiles()">
                    <i class="fas fa-share"></i> Chia s·∫ª t·ªáp
                </button>
                <button type="button" class="btn" onclick="shareSingleFile()">
                    <i class="fas fa-file"></i> Chia s·∫ª 1 file
                </button>
                <button type="button" class="btn" onclick="sendDeliveryReceipt()">
                    <i class="fas fa-check"></i> G·ª≠i x√°c nh·∫≠n ƒë√£ nh·∫≠n
                </button>
                <button type="button" class="btn" onclick="sendReadReceipt()">
                    <i class="fas fa-check-double"></i> ƒê√°nh d·∫•u ƒë√£ ƒë·ªçc
                </button>
                <button type="button" class="btn" onclick="joinConversations()">
                    <i class="fas fa-users"></i> Tham gia conversation
                </button>
                <button type="button" class="btn btn-secondary" onclick="refreshCurrentConversation()">
                    <i class="fas fa-sync-alt"></i> T·∫£i l·∫°i tin nh·∫Øn
                </button>
                <button type="button" class="btn btn-info" onclick="manualRequestLastMessages()"
                    style="font-size: 10px;">
                    <i class="fas fa-comments"></i> Request LastMessages
                </button>
                <button type="button" class="btn btn-success" onclick="testPresence()" style="font-size: 10px;">
                    <i class="fas fa-eye"></i> Test Presence
                </button>
                <button type="button" class="btn btn-danger" onclick="clearChat()">
                    <i class="fas fa-trash"></i> X√≥a chat
                </button>
            </div>

            <!-- Sample Tokens -->
            <div class="section">
                <h3><i class="fas fa-key"></i> Token m·∫´u</h3>
                <div style="font-size: 10px; margin-bottom: 10px; color: #666;">
                    Click ƒë·ªÉ s·ª≠ d·ª•ng token test
                </div>
                <button type="button" class="btn" onclick="useSampleToken('user1')"
                    style="margin-bottom: 5px; font-size: 10px;">
                    üë§ User 1 (68...d1)
                </button>
                <button type="button" class="btn" onclick="useSampleToken('user2')"
                    style="margin-bottom: 5px; font-size: 10px;">
                    üë§ User 2 (Sample)
                </button>
                <div style="font-size: 9px; color: #999; margin-top: 5px;">
                    Ho·∫∑c paste token JWT t·ª´ postman/browser
                </div>
            </div>

            <!-- Debug Section -->
            <div class="section">
                <h3><i class="fas fa-bug"></i> Debug</h3>
                <div class="debug-log" id="debugLog"></div>
            </div>
        </div>

        <!-- Conversations Sidebar -->
        <div class="conversations-sidebar">
            <div class="conversations-header">
                <div style="display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <i class="fas fa-comments"></i>
                    <span>Conversations</span>
                </div>
            </div>

            <div class="conversations-search">
                <input type="text" class="search-input" placeholder="T√¨m ki·∫øm cu·ªôc tr√≤ chuy·ªán..."
                    id="conversationSearch" oninput="filterConversations()">
            </div>

            <div class="conversations-list" id="conversationsList">
                <!-- Conversations will be populated here -->
            </div>

            <button class="new-conversation-btn" onclick="showNewConversationDialog()">
                <i class="fas fa-plus"></i> Cu·ªôc tr√≤ chuy·ªán m·ªõi
            </button>
        </div>

        <!-- Main Chat Area -->
        <div class="main-chat">
            <!-- Chat Header -->
            <div class="chat-header">
                <div class="connection-status">
                    <div class="status-dot" id="statusDot2"></div>
                    <span id="connectionText2">Disconnected</span>
                </div>
                <h2><i class="fas fa-comments"></i> Chat & File Messaging Test</h2>
                <p style="font-size: 12px; opacity: 0.8;">Test c√°c ch·ª©c nƒÉng g·ª≠i tin nh·∫Øn v√† chia s·∫ª t·ªáp</p>
            </div>

            <!-- Messages Container -->
            <div class="messages-container" id="messagesContainer">
                <div class="message received">
                    <div class="message-bubble">
                        <p>üëã Ch√†o m·ª´ng ƒë·∫øn v·ªõi ·ª©ng d·ª•ng test messaging!</p>
                        <p style="font-size: 12px; margin-top: 5px; opacity: 0.8;">
                            ‚Ä¢ G·ª≠i tin nh·∫Øn vƒÉn b·∫£n<br>
                            ‚Ä¢ Upload v√† chia s·∫ª t·ªáp<br>
                            ‚Ä¢ Test c√°c lo·∫°i file kh√°c nhau<br>
                            ‚Ä¢ Theo d√µi tr·∫°ng th√°i real-time
                        </p>
                    </div>
                    <div class="message-info">System ‚Ä¢ v·ª´a xong</div>
                </div>
            </div>

            <!-- Typing Indicator -->
            <div class="typing-indicator" id="typingIndicator">
                <span class="typing-dots">ƒêang nh·∫≠p...</span>
            </div>

            <!-- Message Input Area -->
            <div class="message-input-area">
                <div class="input-container">
                    <textarea class="message-input" id="messageInput" placeholder="Nh·∫≠p tin nh·∫Øn..." rows="1"
                        onkeydown="handleKeyDown(event)" oninput="handleInputChange()"></textarea>
                    <div class="input-actions">
                        <button type="button" class="action-btn file-btn" onclick="triggerFileUpload()"
                            title="ƒê√≠nh k√®m t·ªáp">
                            <i class="fas fa-paperclip"></i>
                        </button>
                        <button type="button" class="action-btn send-btn" id="sendBtn" onclick="sendMessage(event)"
                            title="G·ª≠i tin nh·∫Øn">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let socket = null;
        let currentFilesMetadata = [];
        let isConnected = false;
        let typingTimer = null;
        let currentUser = null;
        let conversations = [];
        let currentConversationId = null;
        let userPresences = new Map();
        let conversationLastMessages = new Map();

        // Cache cho message history c·ªßa m·ªói conversation
        let conversationMessages = new Map(); // Map<conversationId, Array<messages>>
        let conversationMessagesLoaded = new Map(); // Map<conversationId, boolean>

        // ================= TOKEN & USER MANAGEMENT =================

        function parseJWTToken(token) {
            try {
                const base64Url = token.split('.')[1];
                const base64 = base64Url.replace(/-/g, '+').replace(/_/g, '/');
                const jsonPayload = decodeURIComponent(atob(base64).split('').map(function (c) {
                    return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
                }).join(''));
                return JSON.parse(jsonPayload);
            } catch (error) {
                console.error('Error parsing JWT token:', error);
                return null;
            }
        }

        function updateUserInfo(token) {
            const userInfoDiv = document.getElementById('userInfo');

            if (!token) {
                userInfoDiv.innerHTML = 'Ch∆∞a k·∫øt n·ªëi';
                currentUser = null;
                return;
            }

            const payload = parseJWTToken(token);
            if (payload) {
                currentUser = {
                    userId: payload.sub,
                    phoneNumber: payload.phoneNumber,
                    deviceId: payload.deviceId,
                    roles: payload.roles,
                    exp: payload.exp,
                    iat: payload.iat
                };

                const expDate = new Date(payload.exp * 1000);
                const isExpired = expDate < new Date();

                userInfoDiv.innerHTML = `
                    <div style="margin-bottom: 5px;">
                        <strong>User ID:</strong> ${payload.sub || 'N/A'}<br>
                        <strong>Phone:</strong> ${payload.phoneNumber || 'N/A'}<br>
                        <strong>Device:</strong> ${payload.deviceId || 'N/A'}<br>
                        <strong>Roles:</strong> ${(payload.roles || []).join(', ')}<br>
                        <strong>Expires:</strong> <span style="color: ${isExpired ? '#e74c3c' : '#27ae60'};">
                            ${expDate.toLocaleString('vi-VN')} ${isExpired ? '(H·∫øt h·∫°n)' : ''}
                        </span>
                    </div>
                `;
            } else {
                userInfoDiv.innerHTML = '<span style="color: #e74c3c;">Token kh√¥ng h·ª£p l·ªá</span>';
                currentUser = null;
            }
        }

        function clearToken() {
            document.getElementById('accessToken').value = '';
            updateUserInfo(null);
            if (socket && socket.connected) {
                disconnect();
            }
        }

        function generateDeviceId() {
            const timestamp = Date.now();
            const random = Math.random().toString(36).substr(2, 9);
            return `test_device_web_${timestamp}_${random}`;
        }

        function useSampleToken(userType) {
            const sampleTokens = {
                'user1': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI2ODc4YWRiNjljNDE3ODk1NzdiM2I5ZDEiLCJwaG9uZU51bWJlciI6Iis4NDkwMTIzNDU2NyIsImRldmljZUlkIjoibW9iaWxlX2RldmljZV8xMjM0NSIsInJvbGVzIjpbInVzZXIiXSwidHlwZSI6ImFjY2VzcyIsImlhdCI6MTc1Mzc5MjU0MiwiZXhwIjoxNzUzODAxNTQyfQ.HFrrJlCTNLh80VmfPXg5h2KY1D1Jd-1W4cfV2thdCQk',
                'user2': 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiI2ODc4YWRiNjljNDE3ODk1NzdiM2I5ZDIiLCJwaG9uZU51bWJlciI6Iis4NDkwMTIzNDU2OCIsImRldmljZUlkIjoibW9iaWxlX2RldmljZV8xMjM0NiIsInJvbGVzIjpbInVzZXIiXSwidHlwZSI6ImFjY2VzcyIsImlhdCI6MTc1Mzc5MjU0MiwiZXhwIjoxNzUzODAxNTQyfQ.sample_token_for_user2'
            };

            const token = sampleTokens[userType];
            if (token) {
                document.getElementById('accessToken').value = token;
                updateUserInfo(token);
                localStorage.setItem('chatapp_token', token);
                addMessage('system', `üìã ƒê√£ s·ª≠ d·ª•ng token ${userType}`, 'received');
            }
        }

        // ================= CONNECTION MANAGEMENT =================

        function connect() {
            if (socket && socket.connected) {
                addMessage('system', 'ƒê√£ k·∫øt n·ªëi r·ªìi!', 'received');
                return;
            }

            // Get token from input
            const token = document.getElementById('accessToken').value.trim();
            if (!token) {
                addMessage('system', '‚ùå Vui l√≤ng nh·∫≠p access token!', 'received');
                document.getElementById('accessToken').focus();
                return;
            }

            // Validate token format
            const payload = parseJWTToken(token);
            if (!payload) {
                addMessage('system', '‚ùå Token kh√¥ng h·ª£p l·ªá! Vui l√≤ng ki·ªÉm tra l·∫°i.', 'received');
                return;
            }

            // Check if token is expired
            const expDate = new Date(payload.exp * 1000);
            if (expDate < new Date()) {
                addMessage('system', '‚ùå Token ƒë√£ h·∫øt h·∫°n! Vui l√≤ng s·ª≠ d·ª•ng token m·ªõi.', 'received');
                return;
            }

            // Get or generate device ID
            let deviceId = document.getElementById('deviceId').value.trim();
            if (!deviceId) {
                deviceId = generateDeviceId();
                document.getElementById('deviceId').value = deviceId;
            }

            // Update user info
            updateUserInfo(token);

            socket = io('http://localhost:3000/chat', {
                auth: {
                    token: token,
                    deviceId: deviceId,
                    deviceType: 'web',
                    platform: 'web'
                }
            });

            // Connection events
            socket.on('connect', () => {
                updateConnectionStatus(true);
                const userDisplay = currentUser ? `${currentUser.phoneNumber || currentUser.userId}` : 'User';
                addMessage('system', `‚úÖ K·∫øt n·ªëi th√†nh c√¥ng! Ch√†o m·ª´ng ${userDisplay}`, 'received');
                addDebugLog('Connected to server', {
                    socketId: socket.id,
                    user: currentUser,
                    deviceId: deviceId
                });

                // Auto-join the test conversation
                const conversationId = document.getElementById('conversationId').value;
                if (conversationId) {
                    const joinData = {
                        conversationIds: [conversationId]
                    };
                    socket.emit('join_conversations', joinData);
                    addDebugLog('Auto-joined conversation', joinData);
                    addMessage('system', `üë• ƒê√£ t·ª± ƒë·ªông tham gia conversation: ${conversationId}`, 'received');
                }
            });

            socket.on('disconnect', () => {
                updateConnectionStatus(false);
                addMessage('system', '‚ùå M·∫•t k·∫øt n·ªëi!', 'received');
                addDebugLog('Disconnected from server');
            });

            socket.on('connect_error', (error) => {
                updateConnectionStatus(false);
                addMessage('system', `‚ùå L·ªói k·∫øt n·ªëi: ${error.message}`, 'received');
                addDebugLog('Connection error', error, 'error');

                // Handle authentication errors
                if (error.message.includes('Authentication') || error.message.includes('Unauthorized')) {
                    addMessage('system', 'üîë Token c√≥ th·ªÉ ƒë√£ h·∫øt h·∫°n ho·∫∑c kh√¥ng h·ª£p l·ªá. Vui l√≤ng ki·ªÉm tra l·∫°i.', 'received');
                }
            });

            socket.on('offline_messages_batch', datas => {
                datas.messages.forEach(data => {
                    handleNewMessage(data);
                    addDebugLog('offline_messages_batch', data);
                });
            });

            // Message events
            socket.on('new_message', (data) => {
                handleNewMessage(data);
                addDebugLog('new_message', data);
            });

            socket.on('new_file_message', (data) => {
                handleFileMessage(data);
                addDebugLog('new_file_message', data);
            });

            socket.on('new_batch_files_message', (data) => {
                handleBatchFileMessage(data);
                addDebugLog('new_batch_files_message', data);
            });

            // Acknowledgment events
            socket.on('message_received', (data) => {
                addDebugLog('message_received', data);
                if (data.status === 'processed') {
                    // Server processed successfully - add sender's message to UI
                    const messageContent = data.content || 'Tin nh·∫Øn';
                    const senderDisplay = currentUser ? (currentUser.phoneNumber || currentUser.userId) : 'You';
                    addMessage(senderDisplay, messageContent, 'sent', data.localId, data.filesInfo || []);
                    updateMessageStatus(data.localId, 'sent');

                    // Add to message cache for current conversation
                    if (currentConversationId) {
                        addNewMessageToCache(currentConversationId, {
                            messageId: data.messageId || data.localId,
                            content: messageContent,
                            messageType: 'text',
                            senderId: currentUser?.userId,
                            senderName: senderDisplay,
                            timestamp: Date.now(),
                            filesInfo: data.filesInfo || []
                        });

                        // Update lastMessage for current conversation
                        conversationLastMessages.set(currentConversationId, {
                            lastMessage: {
                                messageId: data.messageId || data.localId,
                                content: messageContent,
                                messageType: 'text',
                                senderId: currentUser?.userId,
                                senderName: senderDisplay,
                                timestamp: Date.now(),
                                isRead: true
                            },
                            unreadCount: 0,
                            lastActivity: Date.now()
                        });

                        // Update conversation list
                        renderConversations();
                    }
                } else {
                    updateMessageStatus(data.localId, 'pending');
                }
            });

            socket.on('file_shared', (data) => {
                addDebugLog('file_shared', data);
                // Add sender's file message to UI when server confirms
                const senderDisplay = currentUser ? (currentUser.phoneNumber || currentUser.userId) : 'You';
                const message = data.message || 'Chia s·∫ª t·ªáp';
                addMessage(senderDisplay, `üìÅ ${message}`, 'sent', data.localId, data.fileInfo ? [data.fileInfo] : []);
                updateMessageStatus(data.localId, 'sent');

                // Add to message cache
                if (currentConversationId) {
                    addNewMessageToCache(currentConversationId, {
                        messageId: data.messageId || data.localId,
                        content: `üìÅ ${message}`,
                        messageType: 'file',
                        senderId: currentUser?.userId,
                        senderName: senderDisplay,
                        timestamp: Date.now(),
                        fileInfo: data.fileInfo
                    });
                }
            });

            socket.on('quick_file_shared', (data) => {
                addDebugLog('quick_file_shared', data);
                // Add sender's quick file message to UI when server confirms
                const senderDisplay = currentUser ? (currentUser.phoneNumber || currentUser.userId) : 'You';
                const message = data.message || 'Chia s·∫ª t·ªáp nhanh';
                addMessage(senderDisplay, `üì§ ${message}`, 'sent', data.localId, data.fileInfo ? [data.fileInfo] : []);
                updateMessageStatus(data.localId, 'sent');

                // Add to message cache
                if (currentConversationId) {
                    addNewMessageToCache(currentConversationId, {
                        messageId: data.messageId || data.localId,
                        content: `üì§ ${message}`,
                        messageType: 'file',
                        senderId: currentUser?.userId,
                        senderName: senderDisplay,
                        timestamp: Date.now(),
                        fileInfo: data.fileInfo
                    });
                }
            });

            socket.on('batch_files_shared', (data) => {
                addDebugLog('batch_files_shared', data);
                // Add sender's batch files message to UI when server confirms
                const senderDisplay = currentUser ? (currentUser.phoneNumber || currentUser.userId) : 'You';
                const message = data.message || 'Chia s·∫ª nhi·ªÅu t·ªáp';
                const fileCount = data.filesInfo ? data.filesInfo.length : 0;
                addMessage(senderDisplay, `üì§ ${message} (${fileCount} t·ªáp)`, 'sent', data.localId, data.filesInfo || []);
                updateMessageStatus(data.localId, 'sent');

                // Add to message cache
                if (currentConversationId) {
                    addNewMessageToCache(currentConversationId, {
                        messageId: data.messageId || data.localId,
                        content: `üì§ ${message} (${fileCount} t·ªáp)`,
                        messageType: 'files',
                        senderId: currentUser?.userId,
                        senderName: senderDisplay,
                        timestamp: Date.now(),
                        filesInfo: data.filesInfo
                    });
                }
            });

            // Error events
            socket.on('message_error', (error) => {
                addMessage('system', `‚ùå L·ªói g·ª≠i tin nh·∫Øn: ${error.error}`, 'received');
                addDebugLog('message_error', error, 'error');
                updateMessageStatus(error.localId, 'failed');
            });

            socket.on('share_file_error', (error) => {
                addMessage('system', `‚ùå L·ªói chia s·∫ª file: ${error.error}`, 'received');
                addDebugLog('share_file_error', error, 'error');
                updateMessageStatus(error.localId, 'failed');
            });

            socket.on('quick_share_file_error', (error) => {
                addMessage('system', `‚ùå L·ªói chia s·∫ª file nhanh: ${error.error}`, 'received');
                addDebugLog('quick_share_file_error', error, 'error');
                updateMessageStatus(error.localId, 'failed');
            });

            socket.on('batch_share_files_error', (error) => {
                addMessage('system', `‚ùå L·ªói chia s·∫ª nhi·ªÅu file: ${error.error}`, 'received');
                addDebugLog('batch_share_files_error', error, 'error');
                updateMessageStatus(error.localId, 'failed');
            });

            // ================= PRESENCE EVENTS =================
            socket.on('user_presence_response', (data) => {
                userPresences.set(data.userId, {
                    status: data.status,
                    lastSeen: data.lastSeen,
                    statusMessage: data.statusMessage,
                    deviceCount: data.deviceCount || 0
                });
                updateConversationPresence(data.userId, data.status);
                addDebugLog('user_presence_response', data);
            });

            socket.on('contact_presence_update', (data) => {
                userPresences.set(data.userId, {
                    status: data.status,
                    lastSeen: data.lastSeen,
                    statusMessage: data.statusMessage,
                    deviceCount: data.deviceCount || 0
                });
                updateConversationPresence(data.userId, data.status);
                addDebugLog('contact_presence_update', data);
            });

            socket.on('bulk_presence_response', (data) => {
                if (data.presences) {
                    data.presences.forEach(presence => {
                        userPresences.set(presence.userId, {
                            status: presence.status,
                            lastSeen: presence.lastSeen,
                            statusMessage: presence.statusMessage,
                            deviceCount: presence.deviceCount || 0
                        });
                    });
                    renderConversations();
                }
                addDebugLog('bulk_presence_response', data);
            });

            // ================= LASTMESSAGE EVENTS =================
            socket.on('conversation_last_message_update', (data) => {
                conversationLastMessages.set(data.conversationId, {
                    lastMessage: data.lastMessage,
                    unreadCount: data.unreadCount,
                    lastActivity: data.lastMessage.timestamp
                });
                updateConversationInList(data);
                addDebugLog('conversation_last_message_update', data);
            });

            socket.on('conversations_last_messages_response', (data) => {
                addMessage('system', `‚úÖ Nh·∫≠n ƒë∆∞·ª£c lastMessages cho ${data.updates?.length || 0} conversations`, 'received');

                if (data.updates && Array.isArray(data.updates)) {
                    data.updates.forEach(update => {
                        conversationLastMessages.set(update.conversationId, {
                            lastMessage: update.lastMessage,
                            unreadCount: update.unreadCount,
                            lastActivity: update.lastActivity
                        });

                        addDebugLog('Updated lastMessage for conversation', {
                            conversationId: update.conversationId,
                            lastMessage: update.lastMessage?.content || 'No content',
                            unreadCount: update.unreadCount
                        });
                    });

                    // Re-render conversations to show lastMessages
                    renderConversations();
                    addMessage('system', `üìù ƒê√£ c·∫≠p nh·∫≠t lastMessages v√† re-render conversations`, 'received');
                } else {
                    addMessage('system', '‚ö†Ô∏è Response kh√¥ng c√≥ updates array', 'received');
                }

                addDebugLog('conversations_last_messages_response', data);
            });



            // Setup heartbeat
            setupHeartbeat();

            // Load conversations after connection - v·ªõi proper sequencing
            setTimeout(async () => {
                try {
                    await loadUserConversations();

                    // Delay th√™m ƒë·ªÉ ƒë·∫£m b·∫£o conversations ƒë√£ ƒë∆∞·ª£c set
                    setTimeout(() => {
                        requestPresenceUpdates();
                        requestLastMessages();
                    }, 500);
                } catch (error) {
                    addMessage('system', `‚ùå L·ªói load conversations: ${error.message}`, 'received');
                }
            }, 1000);
        }

        function disconnect() {
            if (socket) {
                socket.disconnect();
                socket = null;
            }
            updateConnectionStatus(false);
            updateUserInfo(null);
            addMessage('system', 'üîå ƒê√£ ng·∫Øt k·∫øt n·ªëi', 'received');
        }

        function updateConnectionStatus(connected) {
            isConnected = connected;
            const statusDots = document.querySelectorAll('.status-dot');
            const statusTexts = document.querySelectorAll('[id^="connectionText"]');

            statusDots.forEach(dot => {
                dot.classList.toggle('connected', connected);
            });

            statusTexts.forEach(text => {
                text.textContent = connected ? 'Connected' : 'Disconnected';
            });

            // Update send button state
            const sendBtn = document.getElementById('sendBtn');
            sendBtn.disabled = !connected;
        }

        // ================= FILE UPLOAD MANAGEMENT =================

        function setupFileUpload() {
            const fileInput = document.getElementById('fileInput');
            const uploadArea = document.getElementById('fileUploadArea');
            const filePreview = document.getElementById('filePreview');

            // Click to select files
            uploadArea.addEventListener('click', () => {
                fileInput.click();
            });

            // Drag and drop
            uploadArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                uploadArea.classList.add('dragover');
            });

            uploadArea.addEventListener('dragleave', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');
            });

            uploadArea.addEventListener('drop', (e) => {
                e.preventDefault();
                uploadArea.classList.remove('dragover');

                const files = Array.from(e.dataTransfer.files);
                handleFileSelection(files);
            });

            // File input change
            fileInput.addEventListener('change', (e) => {
                const files = Array.from(e.target.files);
                handleFileSelection(files);
            });
        }

        function handleFileSelection(files) {
            if (files.length === 0) return;

            const filePreview = document.getElementById('filePreview');
            filePreview.innerHTML = '';

            files.forEach((file, index) => {
                const previewItem = document.createElement('div');
                previewItem.className = 'file-preview-item';
                previewItem.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <i class="fas ${getFileIcon(file.type)}" style="color: ${getFileColor(file.type)};"></i>
                        <div style="flex: 1; min-width: 0;">
                            <div style="font-weight: bold; font-size: 11px; overflow: hidden; text-overflow: ellipsis;">
                                ${file.name}
                            </div>
                            <div style="font-size: 10px; color: #666;">
                                ${formatFileSize(file.size)}
                            </div>
                        </div>
                    </div>
                `;
                filePreview.appendChild(previewItem);
            });

            // Auto-set message type
            if (files.length === 1) {
                const messageTypeSelect = document.getElementById('messageType');
                const file = files[0];
                if (file.type.startsWith('image/')) messageTypeSelect.value = 'image';
                else if (file.type.startsWith('audio/')) messageTypeSelect.value = 'audio';
                else if (file.type.startsWith('video/')) messageTypeSelect.value = 'video';
                else if (file.type.includes('pdf') || file.type.includes('document')) messageTypeSelect.value = 'document';
                else messageTypeSelect.value = 'file';
            } else {
                document.getElementById('messageType').value = 'file';
            }
        }

        // ================= COMPREHENSIVE RELOAD PREVENTION =================

        function preventFormSubmission(event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
                event.stopImmediatePropagation();
            }
            return false;
        }

        async function uploadFiles(event) {
            try {
                // Prevent any form submission behavior
                preventFormSubmission(event);

                const fileInput = document.getElementById('fileInput');
                const files = Array.from(fileInput.files);
                const uploadResult = document.getElementById('uploadResult');

                if (files.length === 0) {
                    uploadResult.innerHTML = '<div style="color: #e74c3c;">‚ö†Ô∏è Vui l√≤ng ch·ªçn t·ªáp tr∆∞·ªõc</div>';
                    return false;
                }

                // Get token from input
                const token = document.getElementById('accessToken').value.trim();
                if (!token) {
                    uploadResult.innerHTML = '<div style="color: #e74c3c;">‚ùå Vui l√≤ng nh·∫≠p access token!</div>';
                    return false;
                }

                // Show loading
                uploadResult.innerHTML = `
                    <div style="color: #3498db;">
                        <i class="fas fa-spinner fa-spin"></i> 
                        ƒêang t·∫£i l√™n ${files.length} t·ªáp...
                    </div>
                `;

                try {
                    const formData = new FormData();
                    files.forEach(file => {
                        formData.append('files', file);
                    });

                    const response = await fetch('http://localhost:3000/api/v1/files/upload/batch', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${token}`
                        },
                        body: formData,
                        redirect: 'manual' // Prevent automatic redirects
                    });

                    // Check for redirect responses that might cause page reload
                    if (response.type === 'opaqueredirect') {
                        throw new Error('Server attempted redirect - blocked to prevent page reload');
                    }

                    if (!response.ok) {
                        throw new Error(`Upload failed: ${response.status} ${response.statusText}`);
                    }

                    const result = await response.json();
                    const filesData = result.data.uploadedFiles || result.files || result;
                    const uploadedFiles = Array.isArray(filesData) ? filesData : [filesData];

                    console.debug('Uploaded files:', uploadedFiles);
                    currentFilesMetadata = uploadedFiles.map(file => ({
                        fileId: file.fileId || file.id,
                        fileName: file.fileName || file.name,
                        fileSize: file.fileSize || file.size,
                        mimeType: file.mimeType || file.type,
                        downloadUrl: file.downloadUrl || file.url,
                        thumbnailUrl: file.thumbnailUrl,
                        dimensions: file.dimensions,
                        duration: file.duration
                    }));

                    console.debug('Current files metadata:', currentFilesMetadata);

                    uploadResult.className = 'upload-result success';
                    uploadResult.innerHTML = `
                        <div style="color: #27ae60; font-weight: bold;">
                            ‚úÖ T·∫£i l√™n th√†nh c√¥ng ${uploadedFiles.length} t·ªáp!
                        </div>
                        <div style="margin-top: 10px; font-size: 10px;">
                            ${uploadedFiles.map(file =>
                        `üìé ${file.fileName || file.name} (${formatFileSize(file.fileSize || file.size)})`
                    ).join('<br>')}
                        </div>
                    `;

                    addMessage('system', `‚úÖ ƒê√£ t·∫£i l√™n ${uploadedFiles.length} t·ªáp`, 'received');

                } catch (error) {
                    console.error('Upload error:', error);
                    uploadResult.className = 'upload-result error';
                    uploadResult.innerHTML = `
                        <div style="color: #e74c3c; font-weight: bold;">
                            ‚ùå L·ªói t·∫£i l√™n: ${error.message}
                        </div>
                        <div style="margin-top: 10px; font-size: 10px;">
                            ‚Ä¢ Ki·ªÉm tra server ƒëang ch·∫°y<br>
                            ‚Ä¢ Ki·ªÉm tra token x√°c th·ª±c<br>
                            ‚Ä¢ Ki·ªÉm tra CORS settings
                        </div>
                    `;
                }
            } catch (globalError) {
                console.error('Global upload error:', globalError);
                // Prevent any potential page reload from unhandled errors
                const uploadResult = document.getElementById('uploadResult');
                if (uploadResult) {
                    uploadResult.innerHTML = '<div style="color: #e74c3c;">‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh. Vui l√≤ng th·ª≠ l·∫°i.</div>';
                }
            }

            return false; // Ensure no form submission
        }

        // ================= FILE DOWNLOAD MANAGEMENT =================

        async function downloadFile(fileName, downloadUrl) {

            console.log('Attempting to download file:', fileName, downloadUrl);
            try {
                // Get token from input
                const token = document.getElementById('accessToken').value.trim();
                if (!token) {
                    addMessage('system', '‚ùå Vui l√≤ng nh·∫≠p access token ƒë·ªÉ download!', 'received');
                    return;
                }

                // Show loading message
                addMessage('system', `‚¨áÔ∏è ƒêang t·∫£i xu·ªëng: ${fileName}...`, 'received');

                const response = await fetch(`${downloadUrl}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (!response.ok) {
                    throw new Error(`Download failed: ${response.status} ${response.statusText}`);
                }

                // Get the file data as blob
                const blob = await response.blob();

                // Create a temporary URL for the blob
                const url = window.URL.createObjectURL(blob);

                // Create a temporary link element and trigger download
                const a = document.createElement('a');
                a.href = url;
                a.download = fileName;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();

                // Clean up
                setTimeout(() => {
                    document.body.removeChild(a);
                    window.URL.revokeObjectURL(url);
                }, 100);

                addMessage('system', `‚úÖ ƒê√£ t·∫£i xu·ªëng th√†nh c√¥ng: ${fileName}`, 'received');

            } catch (error) {
                console.error('Download error:', error);
                addMessage('system', `‚ùå L·ªói t·∫£i xu·ªëng: ${error.message}`, 'received');

                // Alternative: Try opening in new tab with token in URL params (less secure but works)
                try {
                    const token = document.getElementById('accessToken').value.trim();
                    const downloadUrl = `http://localhost:3000/api/v1/files/download/${fileId}?token=${encodeURIComponent(token)}`;
                    window.open(downloadUrl, '_blank');
                    addMessage('system', `üîó ƒê√£ m·ªü link download trong tab m·ªõi (fallback)`, 'received');
                } catch (fallbackError) {
                    console.error('Fallback download error:', fallbackError);
                }
            }
        }

        // ================= MESSAGE HANDLING =================

        function sendMessage(event) {
            try {
                // Prevent any form submission behavior
                preventFormSubmission(event);

                if (!socket || !socket.connected) {
                    addMessage('system', '‚ùå Ch∆∞a k·∫øt n·ªëi! Vui l√≤ng k·∫øt n·ªëi tr∆∞·ªõc.', 'received');
                    return false;
                }

                const messageInput = document.getElementById('messageInput');
                const content = messageInput.value.trim();
                const conversationId = document.getElementById('conversationId').value;
                const type = document.getElementById('messageType').value;

                if (!content && currentFilesMetadata.length === 0) {
                    addMessage('system', '‚ö†Ô∏è Vui l√≤ng nh·∫≠p tin nh·∫Øn ho·∫∑c ch·ªçn t·ªáp', 'received');
                    return false;
                }

                const localId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

                let messageData = {
                    localId: localId,
                    conversationId: conversationId,
                    content: content,
                    type: type,
                    timestamp: Date.now(),
                };

                // Add file data if present - following the ChatGateway DTO structure
                if (currentFilesMetadata.length > 0) {
                    if (currentFilesMetadata.length === 1) {
                        // Single file - can use either fileId or fileMetadata approach
                        const file = currentFilesMetadata[0];
                        if (file.fileId) {
                            // Option 1: Send fileId only (Secure, recommended)
                            messageData.fileId = file.fileId;
                        } else {
                            // Option 2: Send complete metadata (Performance, less secure)
                            messageData.fileMetadata = {
                                fileId: file.fileId || file.id,
                                fileName: file.fileName,
                                fileSize: file.fileSize,
                                mimeType: file.mimeType,
                                downloadUrl: file.downloadUrl,
                                thumbnailUrl: file.thumbnailUrl,
                                duration: file.duration,
                                dimensions: file.dimensions
                            };
                        }
                    } else {
                        // Multiple files - use fileIds or filesMetadata approach
                        const hasAllFileIds = currentFilesMetadata.every(f => f.fileId || f.id);

                        if (hasAllFileIds) {
                            // Option 3: Batch files - fileIds approach (Secure)
                            messageData.fileIds = currentFilesMetadata.map(f => f.fileId || f.id);
                        } else {
                            // Option 4: Batch files with metadata (Performance)
                            messageData.filesMetadata = currentFilesMetadata.map(file => ({
                                fileId: file.fileId || file.id,
                                fileName: file.fileName,
                                fileSize: file.fileSize,
                                mimeType: file.mimeType,
                                downloadUrl: file.downloadUrl,
                                thumbnailUrl: file.thumbnailUrl,
                                duration: file.duration,
                                dimensions: file.dimensions
                            }));
                        }
                    }
                }

                // Send via socket (DO NOT add to UI immediately - wait for server confirmation)
                socket.emit('send_message', messageData);
                addDebugLog('Sent send_message', messageData);

                // Clear input
                messageInput.value = '';
                currentFilesMetadata = [];
                document.getElementById('filePreview').innerHTML = '';
                document.getElementById('fileInput').value = '';
                document.getElementById('uploadResult').innerHTML = '';

                // Reset form
                resizeTextarea(messageInput);
                updateSendButton();

                return false; // Ensure no form submission
            } catch (error) {
                console.error('Send message error:', error);
                addMessage('system', '‚ùå L·ªói g·ª≠i tin nh·∫Øn. Vui l√≤ng th·ª≠ l·∫°i.', 'received');
                return false;
            }
        }

        function sendQuickMessage() {
            const messageInput = document.getElementById('messageInput');
            const quickMessages = [
                'üëã Xin ch√†o!',
                'üòä C·∫£m ∆°n b·∫°n!',
                'üëç OK!',
                '‚ùì B·∫°n c√≥ kh·ªèe kh√¥ng?',
                'üìû G·ªçi cho t√¥i nh√©',
                '‚è∞ H·∫πn g·∫∑p l·∫°i sau'
            ];

            const randomMessage = quickMessages[Math.floor(Math.random() * quickMessages.length)];
            messageInput.value = randomMessage;
            sendMessage();
        }

        function shareFiles() {
            if (currentFilesMetadata.length === 0) {
                addMessage('system', '‚ö†Ô∏è Vui l√≤ng t·∫£i t·ªáp l√™n tr∆∞·ªõc', 'received');
                return;
            }

            if (!socket || !socket.connected) {
                addMessage('system', '‚ùå Ch∆∞a k·∫øt n·ªëi!', 'received');
                return;
            }

            const conversationId = document.getElementById('conversationId').value;
            const message = document.getElementById('messageInput').value || 'Chia s·∫ª t·ªáp';
            const localId = `file_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            if (currentFilesMetadata.length === 1) {
                // Quick share single file - matches QuickShareFileDto
                const file = currentFilesMetadata[0];
                const shareData = {
                    fileId: file.fileId || file.id,
                    conversationId: conversationId,
                    message: message,
                    fileMetadata: {
                        fileName: file.fileName,
                        fileSize: file.fileSize,
                        mimeType: file.mimeType,
                        downloadUrl: file.downloadUrl,
                        thumbnailUrl: file.thumbnailUrl,
                        duration: file.duration,
                        dimensions: file.dimensions
                    }
                };

                // Send to server (DO NOT add to UI immediately)
                socket.emit('quick_share_file', shareData);
                addDebugLog('Sent quick_share_file', shareData);
            } else {
                // Batch share multiple files - matches BatchShareFilesDto
                const shareData = {
                    fileIds: currentFilesMetadata.map(f => f.fileId || f.id),
                    conversationId: conversationId,
                    message: message,
                    filesMetadata: currentFilesMetadata.map(file => ({
                        fileId: file.fileId || file.id,
                        fileName: file.fileName,
                        fileSize: file.fileSize,
                        mimeType: file.mimeType,
                        downloadUrl: file.downloadUrl,
                        thumbnailUrl: file.thumbnailUrl,
                        duration: file.duration,
                        dimensions: file.dimensions
                    }))
                };

                // Send to server (DO NOT add to UI immediately)
                socket.emit('batch_share_files', shareData);
                addDebugLog('Sent batch_share_files', shareData);
            }

            // Clear form
            document.getElementById('messageInput').value = '';
            currentFilesMetadata = [];
            document.getElementById('filePreview').innerHTML = '';
            document.getElementById('fileInput').value = '';
            document.getElementById('uploadResult').innerHTML = '';
        }

        // ================= MESSAGE RENDERING =================

        function addMessage(sender, content, type, localId = null, filesMetadata = []) {
            const messagesContainer = document.getElementById('messagesContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            if (localId) messageDiv.setAttribute('data-local-id', localId);

            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = 'message-bubble';

            let messageHTML = `<p>${content}</p>`;

            // Add file attachments
            if (filesMetadata && filesMetadata.length > 0) {
                if (filesMetadata.length === 1) {
                    const file = filesMetadata[0];
                    messageHTML += createFileAttachment(file);
                } else {
                    messageHTML += createBatchFileAttachment(filesMetadata);
                }
            }

            bubbleDiv.innerHTML = messageHTML;
            messageDiv.appendChild(bubbleDiv);

            const infoDiv = document.createElement('div');
            infoDiv.className = 'message-info';
            const senderDisplay = sender === 'user' && currentUser ?
                (currentUser.phoneNumber || currentUser.userId) : sender;
            infoDiv.textContent = `${senderDisplay} ‚Ä¢ ${formatTime(new Date())}`;
            messageDiv.appendChild(infoDiv);

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function handleNewMessage(data) {
            let content = data.content || 'Tin nh·∫Øn tr·ªëng';
            let filesMetadata = [];

            // Handle file information from new ChatGateway structure
            if (data.fileInfo) {
                filesMetadata = [data.fileInfo];
            }
            if (data.filesInfo) {
                filesMetadata = data.filesInfo;
            }

            // Use senderName from the gateway response
            const senderName = data.senderName || data.senderId || 'Unknown User';

            // Always add to message cache if conversationId is provided
            if (data.conversationId) {
                addNewMessageToCache(data.conversationId, {
                    messageId: data.messageId,
                    content: content,
                    messageType: data.messageType || 'text',
                    senderId: data.senderId,
                    senderName: senderName,
                    timestamp: data.timestamp || Date.now(),
                    filesInfo: filesMetadata
                });

                // Update lastMessage in conversationLastMessages Map
                conversationLastMessages.set(data.conversationId, {
                    lastMessage: {
                        messageId: data.messageId,
                        content: content,
                        messageType: data.messageType || 'text',
                        senderId: data.senderId,
                        senderName: senderName,
                        timestamp: data.timestamp || Date.now(),
                        isRead: data.senderId === currentUser?.userId
                    },
                    unreadCount: data.unreadCount || 0,
                    lastActivity: data.timestamp || Date.now()
                });

                // Update conversation list
                renderConversations();
            }

            // Only display if it's for the current conversation
            if (!data.conversationId || currentConversationId === data.conversationId) {
                addMessage(senderName, content, 'received', null, filesMetadata);
            }
        }

        function handleFileMessage(data) {
            let filesMetadata = [];
            if (data.fileInfo) {
                filesMetadata = [data.fileInfo];
            }

            const senderName = data.senderName || 'User';
            const content = data.content || 'Chia s·∫ª t·ªáp';

            // Always add to message cache if conversationId is provided
            if (data.conversationId) {
                addNewMessageToCache(data.conversationId, {
                    messageId: data.messageId,
                    content: content,
                    messageType: 'file',
                    senderId: data.senderId,
                    senderName: senderName,
                    timestamp: data.timestamp || Date.now(),
                    fileInfo: data.fileInfo
                });
            }

            // Only display if it's for the current conversation
            if (!data.conversationId || currentConversationId === data.conversationId) {
                addMessage(senderName, content, 'received', null, filesMetadata);
            }
        }

        function handleBatchFileMessage(data) {
            let filesMetadata = [];
            if (data.filesInfo) {
                filesMetadata = data.filesInfo;
            }

            const senderName = data.senderName || 'User';
            const content = data.content || 'Chia s·∫ª nhi·ªÅu t·ªáp';

            // Always add to message cache if conversationId is provided
            if (data.conversationId) {
                addNewMessageToCache(data.conversationId, {
                    messageId: data.messageId,
                    content: content,
                    messageType: 'files',
                    senderId: data.senderId,
                    senderName: senderName,
                    timestamp: data.timestamp || Date.now(),
                    filesInfo: data.filesInfo
                });
            }

            // Only display if it's for the current conversation
            if (!data.conversationId || currentConversationId === data.conversationId) {
                addMessage(senderName, content, 'received', null, filesMetadata);
            }
        }

        function createFileAttachment(file) {
            const fileType = getFileTypeFromMimeType(file.mimeType);
            const fileColor = getFileColor(file.mimeType);
            const fileIcon = getFileIcon(file.mimeType);

            return `
                <div class="file-attachment">
                    <div class="file-details">
                        <div class="file-icon" style="background: ${fileColor};">
                            <i class="fas ${fileIcon}"></i>
                        </div>
                        <div class="file-info">
                            <div class="file-name">${file.fileName}</div>
                            <div class="file-size">${formatFileSize(file.fileSize)}</div>
                        </div>
                        <button type="button" class="download-btn" onclick="downloadFile('${file.fileName}','${file.downloadUrl}')">
                            <i class="fas fa-download"></i> T·∫£i v·ªÅ
                        </button>
                    </div>
                </div>
            `;
        }

        function createBatchFileAttachment(files) {
            return `
                <div class="batch-files">
                    <div style="font-weight: bold; margin-bottom: 8px; font-size: 12px;">
                        üì¶ ${files.length} t·ªáp ƒë√≠nh k√®m
                    </div>
                    ${files.map(file => `
                        <div class="batch-file-item">
                            <div class="file-icon" style="background: ${getFileColor(file.mimeType)}; width: 30px; height: 30px; font-size: 12px;">
                                <i class="fas ${getFileIcon(file.mimeType)}"></i>
                            </div>
                            <div class="file-info" style="margin-left: 8px; flex: 1;">
                                <div class="file-name" style="font-size: 11px;">${file.fileName}</div>
                                <div class="file-size" style="font-size: 10px;">${formatFileSize(file.fileSize)}</div>
                            </div>
                            <button type="button" class="download-btn" onclick="downloadFile('${file.fileName}','${file.downloadUrl}')" style="font-size: 10px; padding: 4px 8px;">
                                <i class="fas fa-download"></i>
                            </button>
                        </div>
                    `).join('')}
                </div>
            `;
        }

        function updateMessageStatus(localId, status) {
            const messageElement = document.querySelector(`[data-local-id="${localId}"]`);
            if (messageElement) {
                const infoElement = messageElement.querySelector('.message-info');
                if (infoElement) {
                    const statusIcon = status === 'sent' ? '‚úì' : status === 'delivered' ? '‚úì‚úì' : '‚úì‚úì';
                    infoElement.innerHTML += ` <span style="color: #4facfe;">${statusIcon}</span>`;
                }
            }
        }

        // ================= UI HELPER FUNCTIONS =================

        function handleKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        function handleInputChange() {
            const messageInput = document.getElementById('messageInput');
            resizeTextarea(messageInput);
            updateSendButton();
        }

        function resizeTextarea(textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 100) + 'px';
        }

        function updateSendButton() {
            const messageInput = document.getElementById('messageInput');
            const sendBtn = document.getElementById('sendBtn');
            const hasContent = messageInput.value.trim().length > 0;
            const hasFiles = currentFilesMetadata.length > 0;

            sendBtn.disabled = !isConnected || (!hasContent && !hasFiles);
        }

        function triggerFileUpload() {
            document.getElementById('fileInput').click();
        }

        function clearChat() {
            const messagesContainer = document.getElementById('messagesContainer');
            messagesContainer.innerHTML = `
                <div class="message received">
                    <div class="message-bubble">
                        <p>üí¨ Chat ƒë√£ ƒë∆∞·ª£c x√≥a s·∫°ch!</p>
                    </div>
                    <div class="message-info">System ‚Ä¢ v·ª´a xong</div>
                </div>
            `;
        }

        function sendDeliveryReceipt() {
            if (!socket || !socket.connected) {
                addMessage('system', '‚ùå Ch∆∞a k·∫øt n·ªëi!', 'received');
                return;
            }

            const conversationId = document.getElementById('conversationId').value;
            if (!conversationId) {
                addMessage('system', '‚ö†Ô∏è Vui l√≤ng nh·∫≠p conversation ID', 'received');
                return;
            }

            // Demo message ID - in real app this would be from received messages
            const messageId = `msg_${Date.now()}_demo`;

            const deliveryData = {
                messageId: messageId,
                conversationId: conversationId,
                userId: currentUser?.userId || 'demo_user',
                deliveredAt: Date.now()
            };

            socket.emit('message_delivered', deliveryData);
            addDebugLog('Sent message_delivered', deliveryData);
            addMessage('system', 'üì¨ ƒê√£ g·ª≠i x√°c nh·∫≠n tin nh·∫Øn ƒë√£ nh·∫≠n', 'received');
        }

        function sendReadReceipt() {
            if (!socket || !socket.connected) {
                addMessage('system', '‚ùå Ch∆∞a k·∫øt n·ªëi!', 'received');
                return;
            }

            const conversationId = document.getElementById('conversationId').value;
            if (!conversationId) {
                addMessage('system', '‚ö†Ô∏è Vui l√≤ng nh·∫≠p conversation ID', 'received');
                return;
            }

            // Demo message IDs - in real app these would be from received messages
            const messageIds = [`msg_${Date.now()}_demo1`, `msg_${Date.now()}_demo2`];

            const readReceiptData = {
                conversationId: conversationId,
                messageIds: messageIds,
                userId: currentUser?.userId || 'demo_user',
                readAt: Date.now()
            };

            socket.emit('mark_as_read', readReceiptData);
            addDebugLog('Sent mark_as_read', readReceiptData);
            addMessage('system', 'üëÅÔ∏è ƒê√£ ƒë√°nh d·∫•u tin nh·∫Øn l√† ƒë√£ ƒë·ªçc', 'received');
        }

        function joinConversations() {
            if (!socket || !socket.connected) {
                addMessage('system', '‚ùå Ch∆∞a k·∫øt n·ªëi!', 'received');
                return;
            }

            const conversationId = document.getElementById('conversationId').value;
            if (!conversationId) {
                addMessage('system', '‚ö†Ô∏è Vui l√≤ng nh·∫≠p conversation ID', 'received');
                return;
            }

            const joinData = {
                conversationIds: [conversationId]
            };

            socket.emit('join_conversations', joinData);
            addDebugLog('Sent join_conversations', joinData);
            addMessage('system', `üë• ƒê√£ tham gia conversation: ${conversationId}`, 'received');
        }

        function shareSingleFile() {
            if (currentFilesMetadata.length === 0) {
                addMessage('system', '‚ö†Ô∏è Vui l√≤ng t·∫£i t·ªáp l√™n tr∆∞·ªõc', 'received');
                return;
            }

            if (!socket || !socket.connected) {
                addMessage('system', '‚ùå Ch∆∞a k·∫øt n·ªëi!', 'received');
                return;
            }

            const conversationId = document.getElementById('conversationId').value;
            const message = document.getElementById('messageInput').value || 'Chia s·∫ª t·ªáp ƒë∆°n';
            const localId = `share_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Use the first file for single file sharing - matches ShareFileDto
            const file = currentFilesMetadata[0];
            const shareData = {
                fileId: file.fileId || file.id,
                conversationId: conversationId,
                message: message
            };

            // Send to server (DO NOT add to UI immediately)
            socket.emit('share_file', shareData);
            addDebugLog('Sent share_file', shareData);

            // Clear form
            document.getElementById('messageInput').value = '';
        }

        function addDebugLog(event, data = null, type = '') {
            const debugLog = document.getElementById('debugLog');
            const logEntry = document.createElement('div');
            logEntry.style.marginBottom = '5px';
            logEntry.style.paddingBottom = '5px';
            logEntry.style.borderBottom = '1px solid #34495e';

            const timestamp = new Date().toLocaleTimeString();
            logEntry.innerHTML = `
                <div style="color: #3498db; font-weight: bold;">[${timestamp}] ${event}</div>
                ${data ? `<pre style="margin: 5px 0; font-size: 9px; color: #ecf0f1;">${JSON.stringify(data, null, 2)}</pre>` : ''}
            `;

            if (type === 'error') {
                logEntry.style.color = '#e74c3c';
            }

            debugLog.appendChild(logEntry);
            debugLog.scrollTop = debugLog.scrollHeight;

            // Keep only last 10 logs to prevent memory issues
            while (debugLog.children.length > 10) {
                debugLog.removeChild(debugLog.firstChild);
            }
        }

        // ================= UTILITY FUNCTIONS =================

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function formatTime(date) {
            return date.toLocaleTimeString('vi-VN', {
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function getFileIcon(mimeType) {
            if (mimeType.startsWith('image/')) return 'fa-image';
            if (mimeType.startsWith('video/')) return 'fa-video';
            if (mimeType.startsWith('audio/')) return 'fa-music';
            if (mimeType.includes('pdf')) return 'fa-file-pdf';
            if (mimeType.includes('word') || mimeType.includes('doc')) return 'fa-file-word';
            if (mimeType.includes('excel') || mimeType.includes('sheet')) return 'fa-file-excel';
            if (mimeType.includes('powerpoint') || mimeType.includes('presentation')) return 'fa-file-powerpoint';
            if (mimeType.includes('zip') || mimeType.includes('rar')) return 'fa-file-archive';
            return 'fa-file';
        }

        function getFileColor(mimeType) {
            if (mimeType.startsWith('image/')) return '#e74c3c';
            if (mimeType.startsWith('video/')) return '#9b59b6';
            if (mimeType.startsWith('audio/')) return '#1abc9c';
            if (mimeType.includes('pdf')) return '#e67e22';
            if (mimeType.includes('word') || mimeType.includes('doc')) return '#3498db';
            if (mimeType.includes('excel') || mimeType.includes('sheet')) return '#27ae60';
            if (mimeType.includes('powerpoint') || mimeType.includes('presentation')) return '#f39c12';
            return '#95a5a6';
        }

        function getFileTypeFromMimeType(mimeType) {
            if (mimeType.startsWith('image/')) return 'image';
            if (mimeType.startsWith('audio/')) return 'audio';
            if (mimeType.startsWith('video/')) return 'video';
            if (mimeType.includes('pdf') || mimeType.includes('document') || mimeType.includes('text')) return 'document';
            return 'file';
        }

        // ================= INITIALIZATION =================

        document.addEventListener('DOMContentLoaded', function () {
            setupFileUpload();
            updateConnectionStatus(false);

            // Generate default device ID
            document.getElementById('deviceId').value = generateDeviceId();

            // Load saved token if exists
            const savedToken = localStorage.getItem('chatapp_token');
            if (savedToken) {
                document.getElementById('accessToken').value = savedToken;
                updateUserInfo(savedToken);
            }

            // Save token when input changes
            document.getElementById('accessToken').addEventListener('input', function () {
                const token = this.value.trim();
                if (token) {
                    localStorage.setItem('chatapp_token', token);
                    updateUserInfo(token);
                } else {
                    localStorage.removeItem('chatapp_token');
                    updateUserInfo(null);
                }
            });

            // COMPREHENSIVE RELOAD PREVENTION

            // Prevent all form submissions
            document.addEventListener('submit', function (e) {
                console.log('Form submission prevented:', e.target);
                e.preventDefault();
                e.stopPropagation();
                return false;
            }, true);

            // Prevent Enter key form submissions (except in textarea)
            document.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' && e.target.type !== 'textarea') {
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
            }, true);

            // Prevent any accidental navigation
            window.addEventListener('beforeunload', function (e) {
                // Only show warning if user is connected to chat
                if (socket && socket.connected) {
                    const confirmationMessage = 'B·∫°n c√≥ ch·∫Øc mu·ªën r·ªùi kh·ªèi trang? K·∫øt n·ªëi chat s·∫Ω b·ªã ng·∫Øt.';
                    e.returnValue = confirmationMessage;
                    return confirmationMessage;
                }
            });

            // Add global error handler for fetch
            window.addEventListener('unhandledrejection', function (e) {
                console.error('Unhandled promise rejection (may prevent reload):', e.reason);
                e.preventDefault(); // Prevent potential page reload from unhandled errors
            });

            // Add extra protection against any form-related page reloads
            window.addEventListener('submit', function (e) {
                console.warn('Submit event detected and blocked:', e.target);
                e.preventDefault();
                e.stopPropagation();
                e.stopImmediatePropagation();
                return false;
            }, true);

            // Intercept all button clicks to ensure no form submission
            document.addEventListener('click', function (e) {
                if (e.target.tagName === 'BUTTON' && e.target.type !== 'button') {
                    console.warn('Non-button type detected and prevented:', e.target);
                    e.preventDefault();
                    e.stopPropagation();
                    return false;
                }
            }, true);

            console.log('üöÄ Chat & File Messaging Test App loaded successfully with reload prevention!');
            addDebugLog('App initialized with comprehensive reload prevention', {
                timestamp: new Date().toISOString(),
                preventionFeatures: [
                    'Form submission prevention',
                    'Enter key prevention',
                    'Fetch redirect blocking',
                    'Unhandled error prevention',
                    'Navigation warning'
                ]
            });
        });

        // ================= CONVERSATIONS MANAGEMENT =================

        async function loadUserConversations() {
            try {
                // Get token from input
                const token = document.getElementById('accessToken').value.trim();
                if (!token) {
                    addMessage('system', '‚ùå C·∫ßn access token ƒë·ªÉ t·∫£i conversations!', 'received');
                    return;
                }

                // Show loading state
                const conversationsList = document.getElementById('conversationsList');
                if (conversationsList) {
                    conversationsList.innerHTML = `
                        <div style="padding: 20px; text-align: center; color: #666;">
                            <i class="fas fa-spinner fa-spin" style="font-size: 24px; margin-bottom: 10px; display: block;"></i>
                            ƒêang t·∫£i danh s√°ch cu·ªôc tr√≤ chuy·ªán...
                        </div>
                    `;
                }

                // Call API to get user conversations
                const response = await fetch('http://localhost:3000/api/v1/conversations', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`API call failed: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();
                addDebugLog('Loaded conversations from API', result);

                // Convert API response to internal format
                conversations = result.conversations.map(conv => ({
                    id: conv.id,
                    name: conv.name || `Conversation ${conv.id}`,
                    type: conv.type,
                    avatar: conv.avatarUrl,
                    participants: conv.participants || [],
                    lastActivity: conv.lastMessage ? new Date(conv.lastMessage.createdAt).getTime() : new Date(conv.updatedAt || conv.createdAt).getTime(),
                    unreadCount: conv.unreadCount || 0,
                    isActive: conv.isActive !== false,
                    isPinned: conv.status?.isPinned || false,
                    isArchived: conv.status?.isArchived || false,
                    lastMessage: conv?.lastMessage || "<no message>"
                }));

                // Update conversation last messages from API data
                result.conversations.forEach(conv => {
                    if (conv.lastMessage) {
                        conversationLastMessages.set(conv.id, {
                            lastMessage: {
                                messageId: conv.lastMessage.id,
                                content: conv.lastMessage.content,
                                messageType: conv.lastMessage.messageType,
                                senderId: conv.lastMessage.senderId,
                                senderName: conv.lastMessage.senderId, // Will be updated with real names
                                timestamp: new Date(conv.lastMessage.createdAt).getTime(),
                                isRead: true // Assume read for now
                            },
                            unreadCount: conv.unreadCount || 0,
                            lastActivity: new Date(conv.lastMessage.createdAt).getTime()
                        });
                    }
                });

                addMessage('system', `‚úÖ ƒê√£ t·∫£i ${conversations.length} cu·ªôc tr√≤ chuy·ªán t·ª´ server`, 'received');
                renderConversations();

                // Request lastMessages sau khi conversations ƒë√£ ƒë∆∞·ª£c load
                setTimeout(() => {
                    if (socket && socket.connected) {
                        requestLastMessages();
                    }
                }, 300);

                // Auto-select first conversation if available
                if (conversations.length > 0 && !currentConversationId) {
                    selectConversation(conversations[0].id, conversations[0].name);
                }

            } catch (error) {
                console.error('Failed to load conversations:', error);
                addMessage('system', `‚ùå L·ªói t·∫£i conversations: ${error.message}`, 'received');
                addDebugLog('Load conversations error', error, 'error');

                // Fallback to sample data if API fails
                loadSampleConversations();
            }
        }

        function loadSampleConversations() {
            // Fallback sample conversations data
            conversations = [
                {
                    id: 'test_conv_123',
                    name: 'Test Conversation',
                    type: 'group',
                    avatar: null,
                    participants: [
                        { id: '6878adb69c4178957b3b9d1', name: 'User 1', phoneNumber: '+84901234567' },
                        { id: '6878adb69c4178957b3b9d2', name: 'User 2', phoneNumber: '+84901234568' },
                        { id: 'current_user', name: 'You', phoneNumber: currentUser?.phoneNumber || '+84999999999' }
                    ],
                    lastActivity: Date.now() - 300000, // 5 minutes ago
                    unreadCount: 2,
                    isActive: true
                },
                {
                    id: 'conv_user_1',
                    name: 'John Doe',
                    type: 'direct',
                    avatar: null,
                    participants: [
                        { id: '6878adb69c4178957b3b9d1', name: 'John Doe', phoneNumber: '+84901234567' },
                        { id: 'current_user', name: 'You', phoneNumber: currentUser?.phoneNumber || '+84999999999' }
                    ],
                    lastActivity: Date.now() - 3600000, // 1 hour ago
                    unreadCount: 0,
                    isActive: true
                },
                {
                    id: 'conv_user_2',
                    name: 'Jane Smith',
                    type: 'direct',
                    avatar: null,
                    participants: [
                        { id: '6878adb69c4178957b3b9d2', name: 'Jane Smith', phoneNumber: '+84901234568' },
                        { id: 'current_user', name: 'You', phoneNumber: currentUser?.phoneNumber || '+84999999999' }
                    ],
                    lastActivity: Date.now() - 7200000, // 2 hours ago
                    unreadCount: 1,
                    isActive: true
                }
            ];

            addMessage('system', 'üìã S·ª≠ d·ª•ng sample conversations (API kh√¥ng kh·∫£ d·ª•ng)', 'received');
            renderConversations();
        }

        function renderConversations() {
            const conversationsList = document.getElementById('conversationsList');
            if (!conversationsList) return;

            // Debug: Log conversationLastMessages Map
            addDebugLog('renderConversations - conversationLastMessages Map', {
                size: conversationLastMessages.size,
                entries: Array.from(conversationLastMessages.entries())
            });

            if (conversations.length === 0) {
                conversationsList.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #666; font-style: italic;">
                        <i class="fas fa-comments" style="font-size: 24px; margin-bottom: 10px; display: block;"></i>
                        Ch∆∞a c√≥ cu·ªôc tr√≤ chuy·ªán n√†o<br>
                        <small>K·∫øt n·ªëi ƒë·ªÉ t·∫£i danh s√°ch cu·ªôc tr√≤ chuy·ªán</small>
                    </div>
                `;
                return;
            }

            // Sort conversations by last activity
            const sortedConversations = [...conversations].sort((a, b) => {
                const aLastMessage = conversationLastMessages.get(a.id);
                const bLastMessage = conversationLastMessages.get(b.id);

                const aTime = aLastMessage?.lastActivity || a.lastActivity;
                const bTime = bLastMessage?.lastActivity || b.lastActivity;

                return bTime - aTime;
            });

            conversationsList.innerHTML = sortedConversations.map(conv => {
                const lastMessageData = conversationLastMessages.get(conv.id);
                const isActive = conv.id === currentConversationId;

                // Get online status for direct conversations
                let isOnline = false;
                if (conv.type === 'direct') {
                    const otherUser = conv.participants.find(p => p.id !== 'current_user');
                    if (otherUser) {
                        const presence = userPresences.get(otherUser.id);
                        isOnline = presence?.status === 'online';
                    }
                }

                // Generate avatar
                const avatarContent = conv.avatar
                    ? `<img src="${conv.avatar}" alt="${conv.name}">`
                    : getAvatarPlaceholder(conv.name);

                // Format last message v·ªõi fallback t·ª´ API data tr∆∞·ªõc
                let lastMessageHtml = '';
                if (lastMessageData?.lastMessage) {
                    const msg = lastMessageData.lastMessage;
                    const senderName = msg.senderName === (currentUser?.phoneNumber || currentUser?.userId) ? 'You' : msg.senderName;
                    lastMessageHtml = `
                        <div class="last-message-content">
                            <span class="sender">${senderName}:</span> ${msg.content}
                        </div>
                    `;
                } else if (conv.lastMessage && conv.lastMessage !== "<no message>") {
                    // Fallback to conversation's lastMessage from API
                    const msg = conv.lastMessage;
                    const senderName = typeof msg === 'object' && msg.senderName ?
                        (msg.senderName === (currentUser?.phoneNumber || currentUser?.userId) ? 'You' : msg.senderName) :
                        'Unknown';
                    const content = typeof msg === 'object' ? msg.content : msg;

                    lastMessageHtml = `
                        <div class="last-message-content">
                            <span class="sender">${senderName}:</span> ${content}
                        </div>
                    `;
                } else {
                    lastMessageHtml = `
                        <div class="last-message-content" style="font-style: italic; color: #999;">
                            Ch∆∞a c√≥ tin nh·∫Øn
                        </div>
                    `;
                }

                return `
                    <div class="conversation-item ${isActive ? 'active' : ''}" 
                         onclick="selectConversation('${conv.id}', '${conv.name}')">
                        <div class="conversation-avatar">
                            <div class="avatar">
                                ${avatarContent}
                            </div>
                            <div class="online-indicator ${isOnline ? 'online' : ''}"></div>
                        </div>
                        
                        <div class="conversation-content">
                            <div class="conversation-header">
                                <div class="conversation-name">${conv.name}</div>
                                <div class="conversation-time">
                                    ${formatRelativeTime(lastMessageData?.lastActivity || conv.lastActivity)}
                                </div>
                            </div>
                            
                            <div class="last-message">
                                ${lastMessageHtml}
                                <div class="conversation-badges">
                                    ${lastMessageData?.unreadCount > 0 ? `
                                        <div class="unread-count">${lastMessageData.unreadCount}</div>
                                    ` : ''}
                                    ${lastMessageData?.lastMessage ? `
                                        <div class="read-status ${lastMessageData.lastMessage.isRead ? '' : 'unread'}">
                                            ${lastMessageData.lastMessage.isRead ? '‚úì‚úì' : '‚úì'}
                                        </div>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getAvatarPlaceholder(name) {
            const colors = [
                '#667eea', '#764ba2', '#f093fb', '#f5576c',
                '#4facfe', '#00f2fe', '#43e97b', '#38f9d7',
                '#ffecd2', '#fcb69f', '#a8edea', '#fed6e3'
            ];

            const colorIndex = name.charCodeAt(0) % colors.length;
            const initials = name.split(' ').map(n => n.charAt(0).toUpperCase()).join('').substring(0, 2);

            return initials;
        }

        function formatRelativeTime(timestamp) {
            if (!timestamp) return '';

            const now = Date.now();
            const diff = now - timestamp;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(minutes / 60);
            const days = Math.floor(hours / 24);
            const weeks = Math.floor(days / 7);

            if (minutes < 1) return 'V·ª´a xong';
            if (minutes < 60) return `${minutes} ph√∫t`;
            if (hours < 24) return `${hours} gi·ªù`;
            if (days < 7) return `${days} ng√†y`;
            if (weeks < 4) return `${weeks} tu·∫ßn`;

            return new Date(timestamp).toLocaleDateString('vi-VN');
        }

        async function selectConversation(conversationId, conversationName) {
            currentConversationId = conversationId;

            // Update the conversation ID input
            document.getElementById('conversationId').value = conversationId;

            // Update chat header
            const chatHeaderTitle = document.querySelector('.chat-header h2');
            if (chatHeaderTitle) {
                chatHeaderTitle.textContent = `üí¨ ${conversationName}`;
            }

            // Re-render conversations to show active state
            renderConversations();

            // Load message history for this conversation
            if (conversationMessagesLoaded.has(conversationId)) {
                // Messages already loaded, render from cache
                renderMessagesFromCache(conversationId);
                addMessage('system', `üì± ƒê√£ chuy·ªÉn sang cu·ªôc tr√≤ chuy·ªán: ${conversationName}`, 'received');
            } else {
                // Load messages from API
                clearChat();
                addMessage('system', `üì± ƒêang t·∫£i cu·ªôc tr√≤ chuy·ªán: ${conversationName}`, 'received');

                const messages = await loadConversationMessages(conversationId);
                if (messages.length === 0) {
                    addMessage('system', `üí¨ Cu·ªôc tr√≤ chuy·ªán tr·ªëng: ${conversationName}`, 'received');
                } else {
                    renderMessagesFromCache(conversationId);
                }
            }

            // Join the conversation
            if (socket && socket.connected) {
                const joinData = { conversationIds: [conversationId] };
                socket.emit('join_conversations', joinData);
                addDebugLog('Switched to conversation', { conversationId, conversationName });
            }
        }

        function updateConversationInList(data) {
            // Update the conversation in the list
            const conversation = conversations.find(c => c.id === data.conversationId);
            if (conversation) {
                conversation.lastActivity = data.lastMessage.timestamp;
            }

            // Re-render conversations
            renderConversations();

            // Show notification for new messages in other conversations
            if (data.conversationId !== currentConversationId && data.unreadCount > 0) {
                const conv = conversations.find(c => c.id === data.conversationId);
                if (conv) {
                    addMessage('system', `üí¨ Tin nh·∫Øn m·ªõi t·ª´: ${conv.name}`, 'received');
                }
            }
        }

        function updateConversationPresence(userId, status) {
            // Update online indicators for conversations involving this user
            renderConversations();
        }

        function filterConversations() {
            const searchInput = document.getElementById('conversationSearch');
            const searchTerm = searchInput.value.toLowerCase();

            const conversationItems = document.querySelectorAll('.conversation-item');
            conversationItems.forEach(item => {
                const conversationName = item.querySelector('.conversation-name').textContent.toLowerCase();
                const lastMessage = item.querySelector('.last-message-content').textContent.toLowerCase();

                const matches = conversationName.includes(searchTerm) || lastMessage.includes(searchTerm);
                item.style.display = matches ? 'flex' : 'none';
            });
        }

        function showNewConversationDialog() {
            const conversationId = prompt('Nh·∫≠p ID cu·ªôc tr√≤ chuy·ªán m·ªõi:');
            if (conversationId && conversationId.trim()) {
                const conversationName = prompt('Nh·∫≠p t√™n cu·ªôc tr√≤ chuy·ªán:') || conversationId;

                // Add new conversation
                const newConversation = {
                    id: conversationId.trim(),
                    name: conversationName.trim(),
                    type: 'direct',
                    avatar: null,
                    participants: [
                        { id: 'other_user', name: 'Unknown User', phoneNumber: '+84000000000' },
                        { id: 'current_user', name: 'You', phoneNumber: currentUser?.phoneNumber || '+84999999999' }
                    ],
                    lastActivity: Date.now()
                };

                conversations.unshift(newConversation);
                renderConversations();
                selectConversation(conversationId.trim(), conversationName.trim());
            }
        }

        function requestPresenceUpdates() {
            if (!socket || !socket.connected) return;

            // Get all unique user IDs from conversations
            const userIds = new Set();
            conversations.forEach(conv => {
                conv.participants.forEach(p => {
                    if (p.id !== 'current_user') {
                        userIds.add(p.id);
                    }
                });
            });

            if (userIds.size > 0) {
                socket.emit('get_bulk_presence', { userIds: Array.from(userIds) });
                addDebugLog('Requested presence updates', { userIds: Array.from(userIds) });
            }
        }

        function requestLastMessages() {
            if (!socket || !socket.connected) {
                addMessage('system', '‚ö†Ô∏è Socket ch∆∞a k·∫øt n·ªëi - kh√¥ng th·ªÉ request lastMessages', 'received');
                return;
            }

            const conversationIds = conversations.map(c => c.id);
            if (conversationIds.length > 0) {
                addMessage('system', `üîÑ ƒêang request lastMessages cho ${conversationIds.length} conversations...`, 'received');
                socket.emit('get_conversations_last_messages', { conversationIds });
                addDebugLog('Requested last messages', { conversationIds });
            } else {
                addMessage('system', '‚ö†Ô∏è Kh√¥ng c√≥ conversations ƒë·ªÉ request lastMessages', 'received');
            }
        }

        function testPresence() {
            if (!socket || !socket.connected) {
                addMessage('system', '‚ö†Ô∏è Socket ch∆∞a k·∫øt n·ªëi - kh√¥ng th·ªÉ test presence', 'received');
                return;
            }

            // Test 1: Request bulk presence
            requestPresenceUpdates();
            addMessage('system', 'üîÑ Test 1: ƒê√£ g·ª≠i bulk presence request', 'received');

            // Test 2: Request specific user presence (s·ª≠ d·ª•ng user kh√°c trong conversation)
            const testUserId = '687895cb7dd3bd7b1960762d'; // User ID kh√°c
            socket.emit('get_user_presence', { userId: testUserId });
            addMessage('system', `üîÑ Test 2: ƒê√£ request presence cho user ${testUserId}`, 'received');

            // Test 3: Update own presence status
            socket.emit('update_presence', {
                status: 'online',
                statusMessage: 'Testing presence system'
            });
            addMessage('system', 'üîÑ Test 3: ƒê√£ update presence status th√†nh online', 'received');

            addDebugLog('Presence test completed', {
                bulkRequest: true,
                specificUser: testUserId,
                statusUpdate: 'online'
            });
        }

        // ================= MESSAGE HISTORY MANAGEMENT =================

        async function loadConversationMessages(conversationId, limit = 50) {
            try {
                // Get token from input
                const token = document.getElementById('accessToken').value.trim();
                if (!token) {
                    addMessage('system', '‚ùå C·∫ßn access token ƒë·ªÉ t·∫£i tin nh·∫Øn!', 'received');
                    return [];
                }

                // Show loading state
                const messagesContainer = document.getElementById('messagesContainer');
                messagesContainer.innerHTML = `
                    <div style="padding: 20px; text-align: center; color: #666;">
                        <i class="fas fa-spinner fa-spin" style="font-size: 24px; margin-bottom: 10px; display: block;"></i>
                        ƒêang t·∫£i l·ªãch s·ª≠ tin nh·∫Øn...
                    </div>
                `;

                // Call API to get conversation messages
                const response = await fetch(`http://localhost:3000/api/v1/messages/conversation/${conversationId}?limit=${limit}&page=1`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    throw new Error(`API call failed: ${response.status} ${response.statusText}`);
                }

                const result = await response.json();
                addDebugLog('Loaded conversation messages from API', result);

                // Convert API response to internal format
                const messages = result.messages.map(msg => ({
                    id: msg.id,
                    content: msg.content,
                    messageType: msg.messageType,
                    senderId: msg.senderId,
                    senderName: msg.senderId, // Will be updated with real names from participants
                    conversationId: msg.conversationId,
                    timestamp: new Date(msg.createdAt).getTime(),
                    isRead: true, // Assume read for historical messages
                    filesMetadata: msg.attachments || []
                }));

                // Cache the messages
                conversationMessages.set(conversationId, messages);
                conversationMessagesLoaded.set(conversationId, true);

                addDebugLog('Cached messages for conversation', { conversationId, messageCount: messages.length });
                return messages;

            } catch (error) {
                console.error('Failed to load conversation messages:', error);
                addMessage('system', `‚ùå L·ªói t·∫£i tin nh·∫Øn: ${error.message}`, 'received');
                addDebugLog('Load messages error', error, 'error');

                // Return empty array on error
                return [];
            }
        }

        function renderMessagesFromCache(conversationId) {
            const messages = conversationMessages.get(conversationId) || [];

            // Clear current messages
            const messagesContainer = document.getElementById('messagesContainer');
            messagesContainer.innerHTML = '';

            if (messages.length === 0) {
                messagesContainer.innerHTML = `
                    <div class="message received">
                        <div class="message-bubble">
                            <p>üí¨ Ch∆∞a c√≥ tin nh·∫Øn n√†o trong cu·ªôc tr√≤ chuy·ªán n√†y</p>
                        </div>
                        <div class="message-info">System ‚Ä¢ v·ª´a xong</div>
                    </div>
                `;
                return;
            }

            // Sort messages by timestamp (oldest first)
            messages.sort((a, b) => a.timestamp - b.timestamp);

            // Render each message
            messages.forEach(msg => {
                const messageType = msg.senderId === currentUser?.userId ? 'sent' : 'received';
                const senderName = getSenderDisplayName(msg.senderId, conversationId);

                addMessageToDOM(senderName, msg.content, messageType, msg.id, msg.filesMetadata, new Date(msg.timestamp));
            });

            addMessage('system', `üìú ƒê√£ t·∫£i ${messages.length} tin nh·∫Øn t·ª´ l·ªãch s·ª≠`, 'received');
        }

        function addMessageToDOM(sender, content, type, messageId = null, filesMetadata = [], timestamp = new Date()) {
            const messagesContainer = document.getElementById('messagesContainer');
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            if (messageId) messageDiv.setAttribute('data-message-id', messageId);

            const bubbleDiv = document.createElement('div');
            bubbleDiv.className = 'message-bubble';

            let messageHTML = `<p>${content || 'Tin nh·∫Øn tr·ªëng'}</p>`;

            // Add file attachments
            if (filesMetadata && filesMetadata.length > 0) {
                if (filesMetadata.length === 1) {
                    const file = filesMetadata[0];
                    messageHTML += createFileAttachment(file);
                } else {
                    messageHTML += createBatchFileAttachment(filesMetadata);
                }
            }

            bubbleDiv.innerHTML = messageHTML;
            messageDiv.appendChild(bubbleDiv);

            const infoDiv = document.createElement('div');
            infoDiv.className = 'message-info';
            const senderDisplay = sender === 'user' && currentUser ?
                (currentUser.phoneNumber || currentUser.userId) : sender;
            infoDiv.textContent = `${senderDisplay} ‚Ä¢ ${formatTime(timestamp)}`;
            messageDiv.appendChild(infoDiv);

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function getSenderDisplayName(senderId, conversationId) {
            // Find the conversation to get participant info
            const conversation = conversations.find(c => c.id === conversationId);
            if (!conversation) return senderId;

            // Find the participant
            const participant = conversation.participants.find(p => p.id === senderId);
            if (participant) {
                return participant.name || participant.phoneNumber || senderId;
            }

            // If current user
            if (senderId === currentUser?.userId) {
                return currentUser.phoneNumber || currentUser.userId;
            }

            return senderId;
        }

        function addNewMessageToCache(conversationId, messageData) {
            if (!conversationMessages.has(conversationId)) {
                conversationMessages.set(conversationId, []);
            }

            const messages = conversationMessages.get(conversationId);
            const newMessage = {
                id: messageData.messageId || `temp_${Date.now()}`,
                content: messageData.content,
                messageType: messageData.messageType || 'text',
                senderId: messageData.senderId,
                senderName: messageData.senderName || messageData.senderId,
                conversationId: conversationId,
                timestamp: messageData.timestamp || Date.now(),
                isRead: messageData.senderId === currentUser?.userId,
                filesMetadata: messageData.filesInfo || messageData.fileInfo ? [messageData.fileInfo] : []
            };

            messages.push(newMessage);
            addDebugLog('Added new message to cache', { conversationId, messageId: newMessage.id });
        }

        function clearMessageCache(conversationId = null) {
            if (conversationId) {
                // Clear cache for specific conversation
                conversationMessages.delete(conversationId);
                conversationMessagesLoaded.delete(conversationId);
                addDebugLog('Cleared message cache for conversation', { conversationId });
            } else {
                // Clear all message cache
                conversationMessages.clear();
                conversationMessagesLoaded.clear();
                addDebugLog('Cleared all message cache');
            }
        }

        function refreshConversationMessages(conversationId) {
            // Force reload messages for a conversation
            clearMessageCache(conversationId);
            if (currentConversationId === conversationId) {
                selectConversation(conversationId, getCurrentConversationName(conversationId));
            }
        }

        function getCurrentConversationName(conversationId) {
            const conversation = conversations.find(c => c.id === conversationId);
            return conversation ? conversation.name : 'Unknown';
        }

        function refreshCurrentConversation() {
            if (!currentConversationId) {
                addMessage('system', '‚ö†Ô∏è Ch∆∞a ch·ªçn cu·ªôc tr√≤ chuy·ªán n√†o ƒë·ªÉ t·∫£i l·∫°i!', 'received');
                return;
            }

            const conversationName = getCurrentConversationName(currentConversationId);
            addMessage('system', `üîÑ ƒêang t·∫£i l·∫°i tin nh·∫Øn cho: ${conversationName}`, 'received');

            refreshConversationMessages(currentConversationId);
        }

        function manualRequestLastMessages() {
            addMessage('system', 'üîÑ Manual request lastMessages...', 'received');
            requestLastMessages();
        } function setupHeartbeat() {
            if (!socket || !socket.connected) return;

            // Send heartbeat every 30 seconds
            const heartbeatInterval = setInterval(() => {
                if (socket && socket.connected) {
                    socket.emit('user_heartbeat', {
                        timestamp: Date.now(),
                        deviceInfo: {
                            type: 'web',
                            os: navigator.platform,
                            browser: navigator.userAgent.split(' ').pop()
                        }
                    });
                } else {
                    clearInterval(heartbeatInterval);
                }
            }, 30000);
        }
    </script>
</body>

</html>